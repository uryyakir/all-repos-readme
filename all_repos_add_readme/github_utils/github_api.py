from typing import Optional
from typing import List
from typing import Any
from github import Github
from github.Repository import Repository
from github.GithubException import UnknownObjectException
import json
import logging
# local modules
from all_repos_add_readme._exceptions import RepoReadmeNeedsUpdate
from all_repos_add_readme.constants import TOOL_NAME
from all_repos_add_readme.constants import TOOL_COMMIT_MESSAGE
from all_repos_add_readme.constants import TOOL_COMMIT_SIGNATURE
from all_repos_add_readme.constants import TOOL_LOGGER_NAME
from all_repos_add_readme.github_utils._repo_ignore import RepoIgnore
from all_repos_add_readme.github_utils._github_repo import _Repo
from all_repos_add_readme.github_utils._github_config import _GithubConfig


logger = logging.getLogger(TOOL_LOGGER_NAME)


class GitHubAPI:
    def __init__(self, **kwargs: Any) -> None:
        self._user_input = kwargs["user_input"]
        self._dry_run = kwargs["dry_run"]
        self._commit_message = kwargs["commit_message"][0] + TOOL_COMMIT_SIGNATURE if kwargs["commit_message"] else TOOL_COMMIT_MESSAGE
        self._repo_ignore = RepoIgnore()

    def run_tool(self, github_repo: Repository) -> None:
        _should_ignore = self._repo_ignore.should_ignore(github_repo)
        if not github_repo.fork and not _should_ignore:
            try:
                readme_file = github_repo.get_contents(
                    github_repo.get_readme().path
                )
                readme_content = readme_file.decoded_content.decode()

                if TOOL_NAME in readme_content:
                    # repo already has a README.md file generate by the tool
                    # let's update its stats
                    logger.debug(f"found tool signature in {github_repo.full_name} README file - invoking README update")
                    raise RepoReadmeNeedsUpdate(readme_sha=readme_file.sha)

                else:
                    logger.debug(f"found a README in {github_repo.full_name} that does not contain tool signature - skipping")
                    pass  # noop

            except UnknownObjectException as exc:  # no README
                self._run_tool(github_repo=github_repo, exception=exc)

        elif _should_ignore:
            logger.info(f"skipping {github_repo.full_name}: found in .repoignore")

        elif github_repo.fork:
            logger.debug(f"skipping {github_repo.full_name}: it's a fork")

    def _run_tool(self, github_repo: Repository, exception: UnknownObjectException) -> None:
        logger.info(f"creating README.md for {github_repo.full_name}")
        _repo = _Repo(repo=github_repo)
        readme_content = _repo.generate_readme_string(self._user_input)
        logger.debug(f"finished generating README.md content for repo {github_repo.full_name}")
        dry_run_indented_content = '\n'.join(['\t\t' + line for line in readme_content.split('\n')])
        if isinstance(exception, RepoReadmeNeedsUpdate):
            # specific UC where repo already has a README file generated by this tool
            # we would like to update the README's stats
            if not self._dry_run:
                github_repo.update_file(
                    path="README.md",
                    message=self._commit_message,
                    content=readme_content,
                    sha=exception.sha
                )
                logger.debug(f"finished updating README.md file in repo {github_repo.full_name}!")

            else:
                logger.debug(f"--- dry run: updating existing README.md in repo {github_repo.full_name}:\n"
                             f"\tCommit message: {self._commit_message}\n"
                             f"\tNew file content:\n{dry_run_indented_content}\n")
                logger.info(f"--- dry run: updating existing README.md in repo {github_repo.full_name}")

        else:
            # first use UC, repo has no README so we need to generate one
            if not self._dry_run:
                github_repo.create_file(
                    path="README.md",
                    message=self._commit_message,
                    content=readme_content,
                )
                logger.debug(f"finished creating README.md file in repo {github_repo.full_name}!")

            else:
                logger.debug(f"--- dry run: creating README.md in repo {github_repo.full_name}:\n"
                             f"\tCommit message: {self._commit_message}\n"
                             f"\tNew file content:\n{dry_run_indented_content}\n")
                logger.info(f"--- dry run: creating README.md in repo {github_repo.full_name}")


def main(user_input: Optional[str], dry_run: bool, commit_message: Optional[List[str]] = None) -> int:
    github_api = GitHubAPI(**locals())
    with open('config.json', encoding='utf8') as config_file:
        github_config = _GithubConfig(**json.load(config_file))

    github = Github(login_or_token=github_config.apiKey)
    for github_repo in set(github.get_user().get_repos(affiliation='owner')):
        github_api.run_tool(github_repo=github_repo)
        logger.debug(f"tool run on repo {github_repo.full_name}: done\n{'*' * 10}")

    return 0


if __name__ == "__main__":
    # some random input for testing purposes
    exit(main(None, dry_run=True))
